# O: オープン・クローズドの原則

「ソフトウェアの構成要素(クラス、モジュール、関数など)は拡張に対しては開いていて、修正に対して閉じていなければならない。」
バートランド・メイヤーが言い始めてロバート・C・マーティンがSOLID原則に取り込んだ考え方です。
マーティンは、機能の不変部分をインターフェイスで定義して、バリエーションをサブクラスで定義することを提唱しました。

新しい仕様を足すとき、既存コードを大きく書き換えると影響が広がって壊れやすくなります。
そこで、追加は別の場所で行い、既存部分は触らずに済む形を目指します。

悪い例：通知手段が Slack / メールだったので if 文で分岐していた。後で Teams が増えたときにさらに分岐を追加した。
良い例：Notifier インターフェースを作り、Slack / メール / Teams を実装として差し替える。将来 SMS や Web 通知が増えても既存部分は変更しなくてすむ。

## 補足:「継承より移譲」

is-a の継承で機能を増やすより、has-a で別クラスに処理を任せる設計のほうが安全で柔軟という考え方があります。機能を増やすときに常に継承したほうが良いとは限りません。

# L: リスコフの置換原則

「派生クラスは基底クラスと置き換え可能であるべき」という原則です。
つまり、基底クラスの契約（期待される振る舞い）を壊さないということです。

たとえば次の設計を考えてみます。

- 基底クラス MinervaApiClient の send() は Minerva の health-check API を呼ぶ
- サブクラス MinervaCalendarApiClient の send() は Minerva の calendar API を呼ぶ

このとき「MinervaApiClient を期待しているコードに、MinervaCalendarApiClient を入れても
期待される振る舞いが保たれるか？」を考えてみてください。
APIの目的や契約が変わっているなら、置換不能＝リスコフ違反になり得ます。

# I: インターフェース分離の原則

「使わないメソッドに依存させない」という原則です。
大きなインターフェースにいろいろ詰め込むと、実装クラスが不要なメソッドまで持たされます。

そこで、役割ごとに小さなインターフェースに分け、必要なものだけを実装できるようにします。
結果として、変更の影響が狭くなり、理解もしやすくなります。

悪い例：UserService が「取得・更新・通知・監査ログ」など全部のAPIを持ち、
取得だけの実装にも通知/監査のメソッド実装を強制する。
良い例：UserQuery / UserCommand / UserNotification などに分け、必要なものだけ実装する。

# D: 依存性逆転の原則

「詳細に依存せず、抽象に依存する」という原則です。
上位モジュールが下位モジュールの具体実装に直接依存すると、変更に弱くなります。

インターフェース（抽象）を挟んで依存関係を逆転させると、実装の差し替えが容易になります。
テスト時にモックに置き換えられるのも、この原則の大きなメリットです。

悪い例：Service が `new S3Client()` を直接生成してファイル保存を行う。
良い例：Storage インターフェースを用意し、S3/ローカルをDIで差し替える。

## 補足

我々のチームはSpring Bootを使っていて、Spring AOPとMockitoの強力な機能により、インターフェイスを作らなくてもテストのときに自由にMockに入れ替えることができます。そのため、依存性逆転のためにわざわざインターフェイスを作らなくて大丈夫です。
